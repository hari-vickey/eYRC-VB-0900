#!/usr/bin/env python
# ROS Node - Action Client - Iot ROS Bridge
import rospy
import actionlib
from pkg_task1.msg import msgTurtleAction           # Message Class is used by ROSActions internally
from pkg_task1.msg import msgTurtleGoal             # Message Class is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotAction  # Message Class is used by ROSActions internally
from pkg_ros_iot_bridge.msg import msgRosIotGoal    # Message Class is used for Goal Messages
from pkg_ros_iot_bridge.msg import msgRosIotResult  # Message Class is used for Result Messages
from pkg_ros_iot_bridge.msg import msgMqttSub       # Message Class is used for Mqtt Subscription Messages
class SimpleActionClientTurtle:
    # Constructor
    def __init__(self):
        #Initialize SimpleActionClientTurtle
        self._ac = actionlib.SimpleActionClient('/action_turtle', msgTurtleAction)
        self._ac.wait_for_server()
        rospy.loginfo("Action server is up, we can send new goals!")
    # Function to send Goals to Action Servers
    def send_goal(self, arg_dis, arg_angle):
        # Create Goal message for Simple Action Server
        goal = msgTurtleGoal(distance=arg_dis, angle=arg_angle)
        '''
            * done_cb is set to the function pointer of the function which should be called once 
                the Goal is processed by the Simple Action Server.

            * feedback_cb is set to the function pointer of the function which should be called while
                the goal is being processed by the Simple Action Server.
        ''' 
        self._ac.send_goal(goal, done_cb=self.done_callback, feedback_cb=self.feedback_callback)
        rospy.loginfo("Goal has been sent.")
    # Function print result on Goal completion
    def done_callback(self, status, result):        
        self.result = result
        self.turt_x = result.turtle_x
        self.turt_y = result.turtle_y
        self.turt_theta = result.turtle_theta
    # Function to get feedback while Goal is being processed
    def feedback_callback(self, feedback):
        feedback
class IotRosBridgeActionClient:
    # Constructor
    def __init__(self):
        # Initialize Action Client
        self._ac = actionlib.ActionClient('/action_ros_iot', msgRosIotAction)
        # Dictionary to Store all the goal handels
        self._goal_handles = {}
        # Store the MQTT Topic on which to Publish in a variable
        param_config_iot = rospy.get_param('config_iot')
        self._config_mqtt_pub_topic = param_config_iot['mqtt']['topic_pub']
	# Wait for Action Server that will use the action - '/action_iot_ros' to start
        self._ac.wait_for_server()
        rospy.loginfo("Action server up, we can send goals.")
    # This function will be called when there is a change of state in the Action Client State Machine
    def on_transition(self, goal_handle):
        # from on_goal() to on_transition(). goal_handle generated by send_goal() is used here.
        result = msgRosIotResult()
        index = 0
        for i in self._goal_handles:
            if self._goal_handles[i] == goal_handle:
                index = i
                break
        rospy.loginfo("Transition Callback. Client Goal Handle #: " + str(index))
        rospy.loginfo("Comm. State: " + str(goal_handle.get_comm_state()))
        rospy.loginfo("Goal Status: " + str(goal_handle.get_goal_status()))
        # Comm State - Monitors the State Machine of the Client which is different from Server's
        # Comm State = 2 -> Active
        # Comm State = 3 -> Wating for Result
        # Comm State = 7 -> Done
        # if (Comm State == ACTIVE)
        if goal_handle.get_comm_state() == 2:
            rospy.loginfo(str(index) + ": Goal just went active.")
        # if (Comm State == DONE)
        if goal_handle.get_comm_state() == 7:
            rospy.loginfo(str(index) + ": Goal is DONE")
            rospy.loginfo(goal_handle.get_terminal_state())
            # get_result() gets the result produced by the Action Server
            result = goal_handle.get_result()
            rospy.loginfo(result.flag_success)
            if result.flag_success == True:
                rospy.loginfo("Goal successfully completed. Client Goal Handle #: " + str(index))
            else:
                rospy.loginfo("Goal failed. Client Goal Handle #: " + str(index))
    # This function is used to send Goals to Action Server
    def send_goal(self, arg_protocol, arg_mode, arg_topic, arg_message, arg_turtle_x, arg_turtle_y, arg_turtle_theta):
        # Create a Goal Message object
        goal = msgRosIotGoal()
        goal.protocol = arg_protocol
        goal.mode = arg_mode
        goal.topic = arg_topic
        goal.message = arg_message
	goal.turtle_x = arg_turtle_x
	goal.turtle_y = arg_turtle_y
	goal.turtle_theta = arg_turtle_theta
        rospy.loginfo("Send goal.")
        # self.on_transition - It is a function pointer to a function which will be called when 
        #                       there is a change of state in the Action Client State Machine
        goal_handle = self._ac.send_goal(goal, self.on_transition, None)
        return goal_handle
class MqttTopic:
    def __init__(self):
        #Subscribe to the Mqtt Subscription topic 
        rospy.Subscriber('/ros_iot_bridge/mqtt/sub', msgMqttSub, self.mqtt_callback)
    def mqtt_callback(self, msg):
        message = msg.message
        #sending goals when the subscription message == start
        if message == "start":
   	    # Creating objects to Class
            obj_client = SimpleActionClientTurtle()
            obj_iot = IotRosBridgeActionClient()
   	    #Sending Goals to the Servers
            obj_client.send_goal(2, 0)
            rospy.sleep(5)
            turtle_message = str("("+str(obj_client.turt_x)+","+str(obj_client.turt_y)+","+str(obj_client.turt_theta)+")") 
            obj_iot._goal_handles['1'] = obj_iot.send_goal("mqtt", "pub", obj_iot._config_mqtt_pub_topic, turtle_message, obj_client.turt_x, obj_client.turt_y, obj_client.turt_theta)
            for i in range(1, 6):
                obj_client.send_goal(2, 60)
                rospy.sleep(10)
                turtle_message = str("("+str(obj_client.turt_x)+","+str(obj_client.turt_y)+","+str(obj_client.turt_theta)+")")
                obj_iot._goal_handles[str(i+1)] = obj_iot.send_goal("mqtt", "pub", obj_iot._config_mqtt_pub_topic, turtle_message, obj_client.turt_x, obj_client.turt_y, obj_client.turt_theta)
def main():
    #Initialize Ros Node
    rospy.init_node('node_iot_action_client_turtle')
    #Creating Object to call Class MqttTopic
    MqttTopic()
    #Do not exit and Loop Forever
    rospy.spin()
if __name__ == '__main__':
   main()
