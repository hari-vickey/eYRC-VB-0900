{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to our Documentation Welcome to our documentation, we are participating in e-yantra robotics competition . eYRC is a popular competition across the Globe. Many students wish to participate in this competition, As the competition provides the platform to show case the talents of the students. This competition also motivates the students to learn many things. Also, They have set of mentors who can guide the participants and enhance their learning. Behind this the participants should compete others to learn many things to be in top position. In eYRC 2020-21, the main focus is on Industry 4.0. As Industry 4.0 is a large domain, they have separated the domain into five themes concentrating on complete automation of an traditional industry to an Automated Industry. The themes in this year competition is as follows Nirikshak Bot(NB), Sankatmochan Bot(SM), Sahayak Bot (SB), Vargi Bots (VB), Vitarana Drone (VD). They have selected our team for the Vargi Bots(VB) theme out of these themes. Vargi Bots Theme This theme, concentrates on implementation of autonomous warehouse management system. Since Industry 4.0 heavily focuses on automation here the warehouse will only consist of two industrial robotic arms. As the requirements are sent to the warehouse, one robotic arm will identify the packages from a shelf and place them on a conveyor belt and the other robotic arm at the end of the conveyor belt will pick these objects from the conveyor and place them into bins. Each bin represents a destination for the package. As the packages are sent out from the warehouse there will also be alerts sent to the user via email notifying them about the package being shipped from the warehouse. Our Team ID : VB#0900 In this theme we have learnt ROS, Robotic Manipulation, Robotic Perception, IOT, Google App Scripting, Python and Java script. To implement the complete objective of the theme. In this documentation we have discussed all the methods , techniques and other strategies to improve efficiency of our automated warehouse. Hope you will enjoy reading our documentation","title":"Home"},{"location":"index.html#welcome-to-our-documentation","text":"Welcome to our documentation, we are participating in e-yantra robotics competition . eYRC is a popular competition across the Globe. Many students wish to participate in this competition, As the competition provides the platform to show case the talents of the students. This competition also motivates the students to learn many things. Also, They have set of mentors who can guide the participants and enhance their learning. Behind this the participants should compete others to learn many things to be in top position. In eYRC 2020-21, the main focus is on Industry 4.0. As Industry 4.0 is a large domain, they have separated the domain into five themes concentrating on complete automation of an traditional industry to an Automated Industry. The themes in this year competition is as follows Nirikshak Bot(NB), Sankatmochan Bot(SM), Sahayak Bot (SB), Vargi Bots (VB), Vitarana Drone (VD). They have selected our team for the Vargi Bots(VB) theme out of these themes.","title":"Welcome to our Documentation"},{"location":"index.html#vargi-bots-theme","text":"This theme, concentrates on implementation of autonomous warehouse management system. Since Industry 4.0 heavily focuses on automation here the warehouse will only consist of two industrial robotic arms. As the requirements are sent to the warehouse, one robotic arm will identify the packages from a shelf and place them on a conveyor belt and the other robotic arm at the end of the conveyor belt will pick these objects from the conveyor and place them into bins. Each bin represents a destination for the package. As the packages are sent out from the warehouse there will also be alerts sent to the user via email notifying them about the package being shipped from the warehouse. Our Team ID : VB#0900 In this theme we have learnt ROS, Robotic Manipulation, Robotic Perception, IOT, Google App Scripting, Python and Java script. To implement the complete objective of the theme. In this documentation we have discussed all the methods , techniques and other strategies to improve efficiency of our automated warehouse.","title":"Vargi Bots Theme"},{"location":"index.html#hope-you-will-enjoy-reading-our-documentation","text":"","title":"Hope you will enjoy reading our documentation"},{"location":"about.html","text":"About US Our team consist of four members. All of us are pursuing third year mechatronics engineering at kongu engineering college. This is the first time that we created a documentation for project. If you got any clarification (or) suggestions in the documentation, please feel free to contact us through mail, we will respond you as soon as possible. Thank you for the patient reading. Team Members: P.T Bijoy Antony, M. Hari Vikinesh, E.D. Kavin, B. Adithya Mail ID: eyrc.vb.0900@gmail.com","title":"Contact Us"},{"location":"about.html#about-us","text":"Our team consist of four members. All of us are pursuing third year mechatronics engineering at kongu engineering college. This is the first time that we created a documentation for project. If you got any clarification (or) suggestions in the documentation, please feel free to contact us through mail, we will respond you as soon as possible. Thank you for the patient reading. Team Members: P.T Bijoy Antony, M. Hari Vikinesh, E.D. Kavin, B. Adithya Mail ID: eyrc.vb.0900@gmail.com","title":"About US"},{"location":"api.html","text":"API Documentation In this section, we will discuss about the API's that are used in this theme to complete the objectives mentioned. We have used following ROS packages pkg_ros_iot_bridge pkg_task5 pkg_moveit_ur5_1 and ur5_2 pkg_ros_iot_bridge This is one of the main packages which is required to complete the objective. As this theme is concentrating on development of Automated Warehouse Management System and as we know that an autonomous system needs to do the job on it's own. So, It will receive orders only through IOT i.e., HiveMq and all the status are updated again to the internet medium. So, there is a need of an API which can act as a Bridge between IOT and ROS. As this package is a bridge between ROS and IOT, we need to know the working of this package. We have included the tree of the package , we will discuss all the files and their usage on this package. config_pyiot.yaml To make this package act as a bridge there are certain parameters to be loaded to the ROS Master. This config_pyiot.yaml makes the parameter to be published. All the mqtt topics, ros topics and spreadsheet ids are stored in this yaml file. Hence it can be used in the ROS-IOT action server. Important ros and mqtt topics are listed below # MQtt Topic on which all the orders are sent topic_sub: /eyrc/vb/BiAdKaHa/orders # Unique ID = BiAdKaHa # ROS nodes can listen to this topic to receive data from MQTT sub_cb_ros_topic: /ros_iot_bridge/mqtt/sub Apart from the mqtt and ROS topics, this file also contains the google spreadsheet's webapp ID. This webapp Id can be used to push data to the google sheets. google_apps: //spreadsheet id of our team spread_sheet_id: AKfycbxZjLKDKs_WZ6DHznHcRSnoy2_bh68jGCpYCY4dtaQXAVcoszN8VL4_ //spreadsheet id of the hosts submission_spread_sheet_id: AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7 message and action files These message and action files are used to send and receive data between both ROS nodes and Iot Servers. The Usage of the message file is to store the data of the incoming orders and use the file to publish the same in required format. time timestamp //stores the timestamp of the incoming orders string topic //stores the topic in which the orders are received string message //stores the incoming orders in string format The usage of action files will come into picture when other ROS nodes try to send data to this ROS-IOT action server. So, to receive goal, get feedback and result of the goal. There should be appropriate action files present in the package. The action file used in this package is displayed here. # goal //stores all the incoming goals from client string dispatch_time string shipped_time string sheet_name string order_id string city string package_name string package_color string dispatch_status string shipped_status --- # result // returns the status of the goal once it is processed bool flag_success --- # feedback // to get the status of the goal while processing int8 percentage_complete node_action_server_ros_iot_bridge.py This ros node can get all the data that are published in MQTT Topic with the help of pyiot module. The usage of pyiot module is to do multiprocessing which can parallelly do all the communications between various IOT applications. We have included all the functions present in this node with their descriptions. # ROS Node - Action Server - IoT ROS Bridge ''' This python file runs a ROS-node of name IotRosBridgeActionServer. This node is the bridge between ROS and IOT. This node acts as an Action Server So it will process the goals Asynchronously This node subscribes to the mqtt topic to receive incomingorders This node also publishes the orders received to ros topic All the data are pushed to the spreadsheets using pyiot module ''' # Importing all Required Modules import threading // For asynchronous perfomance from datetime import datetime, timedelta // To get system time and to add dates import json // to convert the incoming orders to dictionary import rospy // To use ROS functions import actionlib // Actionlib library for ROS Communication # Action and Result fields of msgROSIOT.action file for updating status of goal from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotResult # msgMqttSub.msg for publishing the incoming orders to ROS publisher from pkg_ros_iot_bridge.msg import msgMqttSub # Importing Custom IOT Module to communicate between ROS and IOT from pyiot import iot # Class IotRosBridegeActionServer class IotRosBridgeActionServer(object): Class IotRosBridgeActionServer is a action server to node_t5_1 and node_t5_2 # This is a callback function for MQTT Subscriptions def mqtt_sub_callback(self, client, userdata, message): Description : This is a callback function for mqtt Subscription This is function is called whenever, there is a order from the user This function is also threaded to push incoming order to spreadsheet arguments : client - get the client id userdata - get the userdata if any available message - get the orders placed by the client result : Gets the incoming order and publish it in ROS topic # This function will be called when Action Server receives a Goal def on_goal(self, goal_handle): Description : On receiving a goal from client this function will be executed. This function will accept the goals which are appropriate arguments : goal_handle - Incoming goals from clients result : It will either accepts the goal or rejects the goal # This function is a separate thread to process Goal. def process_goal(self, goal_handle): Description : This function is the process goal Asynchronously and calls the appropriate function to push data to spreadsheet arguments : goal_handle - Incoming goals from clients result : send the goal to next stage of process and sends status of goal to clients. # Function to push data to Inventory Sheet @classmethod def func_pushdata_inventory(cls, goal): Description : This function is to push package data in shelf to Inventory spreadsheet using pyiot module. arguments : goal - goal from action client result : push the data to inventory sheet using IOT module. #Function to push data to incoming orders sheet @classmethod def func_pushdata_orders(cls, message): Description : This function is to push incoming orders to IncomingOrders spreadsheet using pyiot module arguments : message - incoming orders from the client result : push the data to IncomingOrders sheet using IOT module. # Function to push data to OrdersDispatched Sheet @classmethod def func_pushdata_dispatch(cls, goal): Description : This function is to push Dispatched orders to OrdersDispatched spreadsheet using pyiot module arguments : goal - goal from action client result : push the data from goal to OrdersDispatched sheet using IOT module. # Function to push data to Ordersshipped Sheet @classmethod def func_pushdata_shipped(cls, goal): Description : This function is to push Shipped package orders to OrdersShipped spreadsheet using pyiot module arguments : goal - goal from action client result : push the data from goal to OrdersShipped sheet using IOT module #Function to cancel a goal @classmethod def on_cancel(cls, goal): Description : This function is to cancel any incoming goal which is requested by the client arguments : goal - goal sent by action client result : cancels the incoming goal by goal id pkg_task5 This is another important package being used in this theme. This ROS package takes complete control of all ROS and Gazebo operations. This package will handle all the incoming orders from the IOT-Bridge, to make appropriate pick and place by ur5_1 arm, then sort the packages with the help of ur5_2 arm. Let us see the tree of this package to get to know the files used and their function one by one. launch files The first necessary thing this package needs to do is launching the simulation environment and all the services files required to complete the tasks. two_ur5_move_group.launch The two_ur5_move_group.launch file will launch the rviz gui for both ur5 arms in two separate windows. The necessity of rviz to avoid collisions that can happen with the objects present in the simulation world. This launch file is integrated with task5_solution file for easy execution. task5_solution.launch The task5_solution.launch file is the main launch file which will be executed at the start of the run. This file will launch the gazebo world with the simulation environment. This file also extends the move group launch file by including the scene file in the respective arms window to avoid collisions. This file also provides an option to record the vacuum_gripper activities of each ur5 arm. With this, we can verify whether the arms are doing their tasks properly. Config and Action files These files are add on to the objective which will give a better performance for this theme. ###### *Config files* In rviz folder there are two scene files namely ur5_1 and ur5_2. The purpose of these scene file is to add all the possible collision objects to the rviz and store them. Then, the stored scene files will be loaded to the rviz gui by the use of launch file. In saved trajectories folder there are thirty seven files. These files are saved trajectories for all the motions that the ur5_1 arm is going to perform. The advantage of this folder to be present in this theme is to execute trajectories without planning a motion with collision aware IK as it's performed earlier and stored it in as a file. The other benefit is that the motion planned is a very optimal trajectory, So that the pick and place can be done as quickly as possible. ###### *Action files* These files will be used for communication between ROS Nodes. These action files will contain all the necessary fields for the goals, feedback and result. We have used colorMsg.action file to carry out the ROS Communication between an action server and action client. # goal //goals to be sent to action server for further processing. string name string color string orderid string city string time int32 simtime --- # result // Stores the result of the processed goals. bool flag_success --- # feedback //stores the status of each goal. int8 percentage_complete ##### **ROS scripts** ROS scripts is the core of this theme. The ROS Nodes present in this package are the atomic units which will use all other files that are present in this package. ###### *node_t5_1.py* This ROS Node is specifically used for ur5_1 arm and it can interface the moveit package of ur5_1 arm to control the arm. The first task that this script needs to do is to use a 2D camera to process the images of the shelf and extract the color of the packages present in the shelf. This Node can also receive incoming orders from the ROS publisher using msgMqttSub which is present in ROS-IOT server package. After receiving the orders, it will be applied to the algorithm to make priority if there are multiple goals to be processed. There are two classes in the node for handling the operations. One class is created separately for the 2D camera. The other Class of this node will handle the incoming goals and manipulate the required packages based on priority. We have included all the functions present in this node with their descriptions. # ROS Node - Robotic Perception and Manipulation - Ur5#1 ''' This python file runs a ROS-node of name Ur51Node. This node acts as a Action client for both Ur5_2 server and ROS-IOT server. So it will send the goals asynchronously to both servers This Node contains two classes one for the 2d camera and ur5_1 Class 2d camera detects the package color and name Class ur5_1 makes the arm to pick and place the package ''' # Importing all the Required Modules import threading // For asynchronous perfomance import datetime // To get system time import json // To convert the incoming orders to dictionary import rospy // To use ROS python functions import actionlib // Actionlib library for ROS import rospkg // To get the required files import yaml // To use saved trajectories import moveit_commander // To interface ur5 arm import moveit_msgs.msg // To get the states of the arm from sensor_msgs.msg import Image // To get the sensor messages of 2D camera from cv_bridge import CvBridge, CvBridgeError // To bridge the raw_data to image format from pyzbar.pyzbar import decode // To decode the QR code from pkg_vb_sim.srv import vacuumGripper // To use the vacuum Gripper service # Action, Goal and Result fields of ColorMsg.action file to access different fields of ROS Actions from pkg_task5.msg import ColorMsgAction, ColorMsgGoal, ColorMsgResult # Action, Goal and Result fields of msgROSIOT.action file to access different fields of ROS Actions from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotGoal, msgRosIotResult # msgMqttSub.msg for subscribing the incoming orders from ROS publisher from pkg_ros_iot_bridge.msg import msgMqttSub # Importing cv2 Module for image processing import cv2 # Create a Class Camera1 class Camera1(object): '''Class Camera1''' This is the image processing unit of this node. This class will detect the package color which is present in shelf # Function for camera def camera(self): Description : This function is an infinite loop which subscribes to the ROS topic of 2d camera to get the input. ROS Subscriber : rospy.Subscriber( /eyrc/vb/camera_1/image_raw , Image, self.callback) arguments : NONE result : returns the package color extracted using image processing return type : list # CallBack Function for Camera subscriber def callback(self, data): Description : This is callback function for camera This function will convert the raw image to bgr8 and calls qr detect function arguments : data - raw_image from ros subscriber result : push the image to qr detect function # Function to detect QR_Code def qr_detect(self, arg_image): Description : This function calls process the images from 2d camera It will crop the image, convert color to grayscale and makes threshold and decode the qr codes. arguments : arg_image - image matrix from callback function result : push the data to re-arranging function # Function to rearrange Image codes def rearrange_img(self, codes): Description : This function re-arranges the decoded data By using the decoded data Re-arrangement is made to get decoded package color in order. arguments : codes - decoded values from qr_detect result : re-arrange image and store it in a list # Creating a class Ur5_1_Node class Ur51Node(object): '''class Ur51Node''' This class acts as a action client for ur5_2 server and ROS-IOT server This class has algorithm to prioritize the package from incomingorders This class also do the pick and place operation # Function to store the color of the package detected in Camera Class def func_store(self): Description : This function is store the package name and color which is extracted from camera class This function is also integrated with a thread which can push data to ROS-IOT server asynchronously while making the arm to move from allZeros to home_point. arguments : NONE result : stores the extracted value from camera1 # Function to receive orders def func_mqtt(self): Description : This function subscribes to the topic /ros_iot_bridge/mqtt/sub to receive the goals which is published from IOT server This function also makes the call to func_algorithm arguments : NONE ROS Subscriber : rospy.Subscriber('/ros_iot_bridge/mqtt/sub', msgMqttSub, self.mqtt_callback) result : orders received will be pushed to algorithm # Callback Function for Mqtt Subscription def mqtt_callback(self, msg): Description : This is a callback function which will execute when order is published in ros topic and converts them to required format. This function will also assign different parameters to various lists which is used later on. arguments : msg - message received from ros subscriber result : converts the received message to suitable form of processing # Function Algorithm to Prioritize Packages def func_algorithm(self, *args): Description : This function algorithm will prioritize the packages if there are multiple orders to be processed. This function also deletes the processed elements from the list. arguments : This is a variadic function which will contain multiple arguments. * args - It has priority, pick color, orderid, city, time, simulationtime result : prioritze the package and sends the function task # Function to Send Goal to IOT server def send_goal_iot(self, *args): Description : This function will send goals to the IOT server from this Node using msgRosIot.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, dispatch time result : sends the goal to ROS IOT server # Function to send goals to Action Server def send_goal_ur5_2(self, *args): Description : This function will send goals to the Ur5_2 server from this Node using ColorMsg.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time result : sends the goal to UR5_2 server # Function to get the state of sent Goal def on_transition1(self, goal_handle): Description : This function monitor the states of all the goals which is sent to ROS-IOT server This function will give the current state of each goal. arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the iot server # Function to get the state of sent Goal def on_transition2(self, goal_handle): Description : This function monitor the states of all the goals which is sent to Ur5_2 server. This function will give the current state of each goal arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the ur5_2 server # Function to push data to Iot Action Server def push_data(self, *args): Description : This function is to pre-process the goals which is to be sent to IOT server using send goal function This function has a if statement according to the sheet name to send goals to the IOT server arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, time, dispatch time result : push the goal to ROS IOT server # Function to complete the task def func_task(self, *args): Description : This function is used to search the prioritized package avaliability in shelf and send the goal to ur5_2 server Once the specified package is identified then the package name and color are removed in the Inventory arguments : This is a variadic function which will contain multiple arguments. * args - It has package color, orderid, city, time, simulation time result : calls the function pick and place # Function to pick and place the package in conveyor def pick_and_place(self, *args): Description : This function makes the arm to pick and place the packages from the shelf to the conveyor The pick and place operation uses pre-defined trajectories which is saved as yaml files in pkg_task5 This function also implemented with a thread to push data to Iot server arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time result : moves the ur5_1 arm to pick the package from shelf and place it in the conveyor # Function to play planned path def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): Description : This function will play the planned path which is saved in the format of yaml file in pkg_task5 Arguments : arg_file_path - file path in which the trajectories are saved arg_file_name - file name of saved trajectories that we need to load result : plays the loaded yaml file. # Function to Hard play planned path def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max): Description : This will play the trajectories multiple times so that trajectories will not fail. Arguments : arg_file_path - file path in which the trajectories are saved arg_file_name - file name of saved trajectories that we need to load arg_max - maximum no of attempts result : gives the result as true or false for the execution of the trajectories ###### *node_t5_2.py* This ROS Node is used for ur5_2 arm and it can interface the moveit package of ut5_2 arm to control the arm. The task of this arm starts only when the ur5_1 arm dispatches the prioritized orders and sends the goal to the server present in this node. On receiving goals from the client it will sort the packages from conveyor to the respective bins based on the color. The first thing that this node needs to do is interface the ur5_2 arm in gazebo with moveit planners. This will be carried out by the constructor of the class UR52Node where all the parameters of the manipulator is loaded. We have included all the functions present in this node with their descriptions. # ROS Node - Robotic Perception and manipulation - Ur5#2 ''' This python file runs a ROS-node of name Ur52Node. This node acts as a Action Server and this node is also an Action client to ROS-IOT server. So it will receive and send the goals asynchronously to the respective nodes This nodes controls the ur5_2 arm to pick the packages from the conveyor belt and drops the package in the respective bins Sorting is done by the goal received from the Action Client ''' # Importing required modules import datetime // To get system time import math // To convert degree to radians import copy // To make a copy of waypoints import threading // For asynchronous perfomance import rospy // To use ROS python functions import actionlib // Actionlib library for ROS import moveit_commander // To interface ur5 arm import moveit_msgs.msg // To get the states of the arm import geometry_msgs.msg // To use the geometry msgs of ROS from pkg_vb_sim.msg import LogicalCameraImage // To get the messages from LogicalCamera2 # To use the vacuum Gripper service, ConveyorBeltService from pkg_vb_sim.srv import conveyorBeltPowerMsg, vacuumGripper # Action and Result fields of ColorMsg.action file to access different fields of ROS Actions from pkg_task5.msg import ColorMsgAction, ColorMsgResult # Action, Goal and Result fields of msgROSIOT.action file to access different fields of ROS Actions from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotGoal, msgRosIotResult # Creating a Class Ur52Node class Ur52Node(object): '''Class UR52Node''' This class will act as controller for ur5_2 arm to pick the packages from the conveyor belt and drops it in the corresponding colored bins # Function to call neccesary parameters def func_nec(self): Description : This functions purpose to initialize several parameters and joint angles to make the arm work properly arguments : NONE results : Initialize the neccessary services and joint angles # Function to validate incoming goal def on_goal(self, goal_handle): Description : On receiving a goal from client this function will be executed. This function will accept the goals which are appropriate arguments : goal_handle - Incoming goals from clients result : It will either accepts the goal or rejects the goal # This function is to process incoming Goals. def process_goal(self, goal_handle): Description : This function is the process goal which is received from action client to sort the packages arguments : goal_handle - Incoming goals from clients result : send the goal to next stage of process and sends status of goal to clients. # Function to Send Goal to IOT server def send_goal_iot(self, *args): Description : This function will send goals to the IOT server from this Node using msgRosIot.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, dispatch time result : sends the goal to ROS IOT server # Function to get the state of sent Goal def on_transition(self, goal_handle): Description : This function monitor the states of all the goals which is sent to ROS-IOT server This function will give the current state of each goal. arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the iot server # Function to sort the packages def func_for_sorting(self, *args): Description : This function will use the incoming goal parameters and sort the packages to the respective bins This function first calls some functions to stop the coveyor belt at appropriate position and to apply translation to the arm to go to the package. This function is also threaded to send goals to IOT server asynchronously arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time results : picks the package from conveyor and place it in the respective bins # Function to push data to ROS-IOT Server def push_data(self, *args): Description : This function is to pre-process the goals which is to be sent to IOT server using send goal function This function has a if statement according to the sheet name to send goals to the IOT server arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, time, dispatch time result : push the goal to ROS IOT server # Function to get translational Values def func_translation(self): Description : this function trasnslation subscribes to the logical camera 2 topic and applies cartesian translation to make the arm move to the package arguments : NONE ROS Subscriber : /eyrc/vb/logical_camera_2 result : push the translational values to ee_cartesian translation function return : float - translation_y # Callback Function for translation function def func_trans_callback(self, msg): Description : this is a callback function to get the translational values which in turn applied in cartesian translation arguments : msg - message received from ros subscriber of logical camera result : gets the y co-ordinate of the packages for applying translation # Function to control conveyor def func_control(self): Description : This function controls the conveyor belt to start and stop func_detect is called to detect whether any objects present in the belt and then it stops the belt. arguments : NONE result : Turn on and off the conveyor belt. # Function to Detect packages def func_detect(self): Description : this function detects whether there is a package in conveyor belt or not using logical camera 2. It also returns the val_y so that it can be picked by ur5_2 arm. arguments : NONE result : detects the package when it is in specific range # Callback Function for detect function def func_sub_callback(self, msg): Description : This function is a callback for func_detect In this function it will check for the packages rather than ur5 arm , so that the packages are identified by the camera and returns the y co-ordinate of the objects arguments : msg - message received from ros subscriber of logical camera 2 result : get the y position of the package return : float - value_y # Function to power up the conveyor while sorting def func_parallel(self): Description : this function to run the conveyor belt parallely while sorting the packages arguments : NONE result : power up the conveyor belt #Function to set_joint_angles to move ur5 arm def set_joint_angles(self, arg_list_joint_angles): Description : This function to set the joint angles of the ur5_2 arm to the required joint angles as mentioned. arguments : arg_list_joint_angles - list of joint angle values result : Moves the arm to the required joint angles # Function to set joint angles forcibly def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): Description : This function to set the joint angles forcibly of the ur5_2 arm In case, If the arm fails to set the joint angles at the first attempt arguments : arg_list_joint_angles - list of joint angle values arg_max_attempts - maximum number of attempts results : gives the result as true or false for the execution of the trajectories # Function for cartesian translation def ee_cartesian_translation(self, trans_x, trans_y, trans_z): Description : This ee_cartesian_translation function is to move the end effector to the packages, the values are extracted using logical camera 2 arguments : trans_x - x co-ordinate value for translation trans_y - y co-ordinate value for translation trans_z - z co-ordinate value for translation result : translate the arm from current position to top of package #Function to cancel a goal @classmethod def on_cancel(cls, goal_handle): Description : This function is to cancel any incoming goal which is requested by the client arguments : goal - goal sent by action client result : cancels the incoming goal by goal id **Note** : If you need to see our complete code, please check on our submission files. #### pkg_moveit_ur5_1 and ur5_2 As discussed in the introduction and implementation, In this theme there are two robotic arms to be controlled. To control each arm, there is a need of a configuration package which should load all the parameters and interface the arm in both gazebo and moveit. We have configured this package on our own instead of the packages that are already available in vb_simulation_pkgs. The reason behind this is to get a best suitable configuration to the ur5 arms and we have also used RRT as a planning library. So, that the arm works better and gives the desired results. This package will have all the files which are necessary to interface and control the arm through move it and ROS nodes. Using the Rviz GUI we have also created a scene file which can use a saved file to avoid collisions with objects present in the gazebo world. The scene file of ur5_1 and ur5_2 are shown below ![scene_2](images/scene.png)","title":"API Documentation"},{"location":"api.html#api-documentation","text":"In this section, we will discuss about the API's that are used in this theme to complete the objectives mentioned. We have used following ROS packages pkg_ros_iot_bridge pkg_task5 pkg_moveit_ur5_1 and ur5_2","title":"API Documentation"},{"location":"api.html#pkg_ros_iot_bridge","text":"This is one of the main packages which is required to complete the objective. As this theme is concentrating on development of Automated Warehouse Management System and as we know that an autonomous system needs to do the job on it's own. So, It will receive orders only through IOT i.e., HiveMq and all the status are updated again to the internet medium. So, there is a need of an API which can act as a Bridge between IOT and ROS. As this package is a bridge between ROS and IOT, we need to know the working of this package. We have included the tree of the package , we will discuss all the files and their usage on this package. config_pyiot.yaml To make this package act as a bridge there are certain parameters to be loaded to the ROS Master. This config_pyiot.yaml makes the parameter to be published. All the mqtt topics, ros topics and spreadsheet ids are stored in this yaml file. Hence it can be used in the ROS-IOT action server. Important ros and mqtt topics are listed below # MQtt Topic on which all the orders are sent topic_sub: /eyrc/vb/BiAdKaHa/orders # Unique ID = BiAdKaHa # ROS nodes can listen to this topic to receive data from MQTT sub_cb_ros_topic: /ros_iot_bridge/mqtt/sub Apart from the mqtt and ROS topics, this file also contains the google spreadsheet's webapp ID. This webapp Id can be used to push data to the google sheets. google_apps: //spreadsheet id of our team spread_sheet_id: AKfycbxZjLKDKs_WZ6DHznHcRSnoy2_bh68jGCpYCY4dtaQXAVcoszN8VL4_ //spreadsheet id of the hosts submission_spread_sheet_id: AKfycbw5xylppoda-8HPjt2Tzq4ShU_Xef-Ik-hEtBPcPk0gdGw8095j4RZ7 message and action files These message and action files are used to send and receive data between both ROS nodes and Iot Servers. The Usage of the message file is to store the data of the incoming orders and use the file to publish the same in required format. time timestamp //stores the timestamp of the incoming orders string topic //stores the topic in which the orders are received string message //stores the incoming orders in string format The usage of action files will come into picture when other ROS nodes try to send data to this ROS-IOT action server. So, to receive goal, get feedback and result of the goal. There should be appropriate action files present in the package. The action file used in this package is displayed here. # goal //stores all the incoming goals from client string dispatch_time string shipped_time string sheet_name string order_id string city string package_name string package_color string dispatch_status string shipped_status --- # result // returns the status of the goal once it is processed bool flag_success --- # feedback // to get the status of the goal while processing int8 percentage_complete node_action_server_ros_iot_bridge.py This ros node can get all the data that are published in MQTT Topic with the help of pyiot module. The usage of pyiot module is to do multiprocessing which can parallelly do all the communications between various IOT applications. We have included all the functions present in this node with their descriptions. # ROS Node - Action Server - IoT ROS Bridge ''' This python file runs a ROS-node of name IotRosBridgeActionServer. This node is the bridge between ROS and IOT. This node acts as an Action Server So it will process the goals Asynchronously This node subscribes to the mqtt topic to receive incomingorders This node also publishes the orders received to ros topic All the data are pushed to the spreadsheets using pyiot module ''' # Importing all Required Modules import threading // For asynchronous perfomance from datetime import datetime, timedelta // To get system time and to add dates import json // to convert the incoming orders to dictionary import rospy // To use ROS functions import actionlib // Actionlib library for ROS Communication # Action and Result fields of msgROSIOT.action file for updating status of goal from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotResult # msgMqttSub.msg for publishing the incoming orders to ROS publisher from pkg_ros_iot_bridge.msg import msgMqttSub # Importing Custom IOT Module to communicate between ROS and IOT from pyiot import iot # Class IotRosBridegeActionServer class IotRosBridgeActionServer(object): Class IotRosBridgeActionServer is a action server to node_t5_1 and node_t5_2 # This is a callback function for MQTT Subscriptions def mqtt_sub_callback(self, client, userdata, message): Description : This is a callback function for mqtt Subscription This is function is called whenever, there is a order from the user This function is also threaded to push incoming order to spreadsheet arguments : client - get the client id userdata - get the userdata if any available message - get the orders placed by the client result : Gets the incoming order and publish it in ROS topic # This function will be called when Action Server receives a Goal def on_goal(self, goal_handle): Description : On receiving a goal from client this function will be executed. This function will accept the goals which are appropriate arguments : goal_handle - Incoming goals from clients result : It will either accepts the goal or rejects the goal # This function is a separate thread to process Goal. def process_goal(self, goal_handle): Description : This function is the process goal Asynchronously and calls the appropriate function to push data to spreadsheet arguments : goal_handle - Incoming goals from clients result : send the goal to next stage of process and sends status of goal to clients. # Function to push data to Inventory Sheet @classmethod def func_pushdata_inventory(cls, goal): Description : This function is to push package data in shelf to Inventory spreadsheet using pyiot module. arguments : goal - goal from action client result : push the data to inventory sheet using IOT module. #Function to push data to incoming orders sheet @classmethod def func_pushdata_orders(cls, message): Description : This function is to push incoming orders to IncomingOrders spreadsheet using pyiot module arguments : message - incoming orders from the client result : push the data to IncomingOrders sheet using IOT module. # Function to push data to OrdersDispatched Sheet @classmethod def func_pushdata_dispatch(cls, goal): Description : This function is to push Dispatched orders to OrdersDispatched spreadsheet using pyiot module arguments : goal - goal from action client result : push the data from goal to OrdersDispatched sheet using IOT module. # Function to push data to Ordersshipped Sheet @classmethod def func_pushdata_shipped(cls, goal): Description : This function is to push Shipped package orders to OrdersShipped spreadsheet using pyiot module arguments : goal - goal from action client result : push the data from goal to OrdersShipped sheet using IOT module #Function to cancel a goal @classmethod def on_cancel(cls, goal): Description : This function is to cancel any incoming goal which is requested by the client arguments : goal - goal sent by action client result : cancels the incoming goal by goal id","title":"pkg_ros_iot_bridge"},{"location":"api.html#pkg_task5","text":"This is another important package being used in this theme. This ROS package takes complete control of all ROS and Gazebo operations. This package will handle all the incoming orders from the IOT-Bridge, to make appropriate pick and place by ur5_1 arm, then sort the packages with the help of ur5_2 arm. Let us see the tree of this package to get to know the files used and their function one by one.","title":"pkg_task5"},{"location":"api.html#launch-files","text":"The first necessary thing this package needs to do is launching the simulation environment and all the services files required to complete the tasks.","title":"launch files"},{"location":"api.html#two_ur5_move_grouplaunch","text":"The two_ur5_move_group.launch file will launch the rviz gui for both ur5 arms in two separate windows. The necessity of rviz to avoid collisions that can happen with the objects present in the simulation world. This launch file is integrated with task5_solution file for easy execution.","title":"two_ur5_move_group.launch"},{"location":"api.html#task5_solutionlaunch","text":"The task5_solution.launch file is the main launch file which will be executed at the start of the run. This file will launch the gazebo world with the simulation environment. This file also extends the move group launch file by including the scene file in the respective arms window to avoid collisions. This file also provides an option to record the vacuum_gripper activities of each ur5 arm. With this, we can verify whether the arms are doing their tasks properly.","title":"task5_solution.launch"},{"location":"api.html#config-and-action-files","text":"These files are add on to the objective which will give a better performance for this theme. ###### *Config files* In rviz folder there are two scene files namely ur5_1 and ur5_2. The purpose of these scene file is to add all the possible collision objects to the rviz and store them. Then, the stored scene files will be loaded to the rviz gui by the use of launch file. In saved trajectories folder there are thirty seven files. These files are saved trajectories for all the motions that the ur5_1 arm is going to perform. The advantage of this folder to be present in this theme is to execute trajectories without planning a motion with collision aware IK as it's performed earlier and stored it in as a file. The other benefit is that the motion planned is a very optimal trajectory, So that the pick and place can be done as quickly as possible. ###### *Action files* These files will be used for communication between ROS Nodes. These action files will contain all the necessary fields for the goals, feedback and result. We have used colorMsg.action file to carry out the ROS Communication between an action server and action client. # goal //goals to be sent to action server for further processing. string name string color string orderid string city string time int32 simtime --- # result // Stores the result of the processed goals. bool flag_success --- # feedback //stores the status of each goal. int8 percentage_complete ##### **ROS scripts** ROS scripts is the core of this theme. The ROS Nodes present in this package are the atomic units which will use all other files that are present in this package. ###### *node_t5_1.py* This ROS Node is specifically used for ur5_1 arm and it can interface the moveit package of ur5_1 arm to control the arm. The first task that this script needs to do is to use a 2D camera to process the images of the shelf and extract the color of the packages present in the shelf. This Node can also receive incoming orders from the ROS publisher using msgMqttSub which is present in ROS-IOT server package. After receiving the orders, it will be applied to the algorithm to make priority if there are multiple goals to be processed. There are two classes in the node for handling the operations. One class is created separately for the 2D camera. The other Class of this node will handle the incoming goals and manipulate the required packages based on priority. We have included all the functions present in this node with their descriptions. # ROS Node - Robotic Perception and Manipulation - Ur5#1 ''' This python file runs a ROS-node of name Ur51Node. This node acts as a Action client for both Ur5_2 server and ROS-IOT server. So it will send the goals asynchronously to both servers This Node contains two classes one for the 2d camera and ur5_1 Class 2d camera detects the package color and name Class ur5_1 makes the arm to pick and place the package ''' # Importing all the Required Modules import threading // For asynchronous perfomance import datetime // To get system time import json // To convert the incoming orders to dictionary import rospy // To use ROS python functions import actionlib // Actionlib library for ROS import rospkg // To get the required files import yaml // To use saved trajectories import moveit_commander // To interface ur5 arm import moveit_msgs.msg // To get the states of the arm from sensor_msgs.msg import Image // To get the sensor messages of 2D camera from cv_bridge import CvBridge, CvBridgeError // To bridge the raw_data to image format from pyzbar.pyzbar import decode // To decode the QR code from pkg_vb_sim.srv import vacuumGripper // To use the vacuum Gripper service # Action, Goal and Result fields of ColorMsg.action file to access different fields of ROS Actions from pkg_task5.msg import ColorMsgAction, ColorMsgGoal, ColorMsgResult # Action, Goal and Result fields of msgROSIOT.action file to access different fields of ROS Actions from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotGoal, msgRosIotResult # msgMqttSub.msg for subscribing the incoming orders from ROS publisher from pkg_ros_iot_bridge.msg import msgMqttSub # Importing cv2 Module for image processing import cv2 # Create a Class Camera1 class Camera1(object): '''Class Camera1''' This is the image processing unit of this node. This class will detect the package color which is present in shelf # Function for camera def camera(self): Description : This function is an infinite loop which subscribes to the ROS topic of 2d camera to get the input. ROS Subscriber : rospy.Subscriber( /eyrc/vb/camera_1/image_raw , Image, self.callback) arguments : NONE result : returns the package color extracted using image processing return type : list # CallBack Function for Camera subscriber def callback(self, data): Description : This is callback function for camera This function will convert the raw image to bgr8 and calls qr detect function arguments : data - raw_image from ros subscriber result : push the image to qr detect function # Function to detect QR_Code def qr_detect(self, arg_image): Description : This function calls process the images from 2d camera It will crop the image, convert color to grayscale and makes threshold and decode the qr codes. arguments : arg_image - image matrix from callback function result : push the data to re-arranging function # Function to rearrange Image codes def rearrange_img(self, codes): Description : This function re-arranges the decoded data By using the decoded data Re-arrangement is made to get decoded package color in order. arguments : codes - decoded values from qr_detect result : re-arrange image and store it in a list # Creating a class Ur5_1_Node class Ur51Node(object): '''class Ur51Node''' This class acts as a action client for ur5_2 server and ROS-IOT server This class has algorithm to prioritize the package from incomingorders This class also do the pick and place operation # Function to store the color of the package detected in Camera Class def func_store(self): Description : This function is store the package name and color which is extracted from camera class This function is also integrated with a thread which can push data to ROS-IOT server asynchronously while making the arm to move from allZeros to home_point. arguments : NONE result : stores the extracted value from camera1 # Function to receive orders def func_mqtt(self): Description : This function subscribes to the topic /ros_iot_bridge/mqtt/sub to receive the goals which is published from IOT server This function also makes the call to func_algorithm arguments : NONE ROS Subscriber : rospy.Subscriber('/ros_iot_bridge/mqtt/sub', msgMqttSub, self.mqtt_callback) result : orders received will be pushed to algorithm # Callback Function for Mqtt Subscription def mqtt_callback(self, msg): Description : This is a callback function which will execute when order is published in ros topic and converts them to required format. This function will also assign different parameters to various lists which is used later on. arguments : msg - message received from ros subscriber result : converts the received message to suitable form of processing # Function Algorithm to Prioritize Packages def func_algorithm(self, *args): Description : This function algorithm will prioritize the packages if there are multiple orders to be processed. This function also deletes the processed elements from the list. arguments : This is a variadic function which will contain multiple arguments. * args - It has priority, pick color, orderid, city, time, simulationtime result : prioritze the package and sends the function task # Function to Send Goal to IOT server def send_goal_iot(self, *args): Description : This function will send goals to the IOT server from this Node using msgRosIot.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, dispatch time result : sends the goal to ROS IOT server # Function to send goals to Action Server def send_goal_ur5_2(self, *args): Description : This function will send goals to the Ur5_2 server from this Node using ColorMsg.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time result : sends the goal to UR5_2 server # Function to get the state of sent Goal def on_transition1(self, goal_handle): Description : This function monitor the states of all the goals which is sent to ROS-IOT server This function will give the current state of each goal. arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the iot server # Function to get the state of sent Goal def on_transition2(self, goal_handle): Description : This function monitor the states of all the goals which is sent to Ur5_2 server. This function will give the current state of each goal arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the ur5_2 server # Function to push data to Iot Action Server def push_data(self, *args): Description : This function is to pre-process the goals which is to be sent to IOT server using send goal function This function has a if statement according to the sheet name to send goals to the IOT server arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, time, dispatch time result : push the goal to ROS IOT server # Function to complete the task def func_task(self, *args): Description : This function is used to search the prioritized package avaliability in shelf and send the goal to ur5_2 server Once the specified package is identified then the package name and color are removed in the Inventory arguments : This is a variadic function which will contain multiple arguments. * args - It has package color, orderid, city, time, simulation time result : calls the function pick and place # Function to pick and place the package in conveyor def pick_and_place(self, *args): Description : This function makes the arm to pick and place the packages from the shelf to the conveyor The pick and place operation uses pre-defined trajectories which is saved as yaml files in pkg_task5 This function also implemented with a thread to push data to Iot server arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time result : moves the ur5_1 arm to pick the package from shelf and place it in the conveyor # Function to play planned path def moveit_play_planned_path_from_file(self, arg_file_path, arg_file_name): Description : This function will play the planned path which is saved in the format of yaml file in pkg_task5 Arguments : arg_file_path - file path in which the trajectories are saved arg_file_name - file name of saved trajectories that we need to load result : plays the loaded yaml file. # Function to Hard play planned path def moveit_hard_play_planned_path_from_file(self, arg_file_path, arg_file_name, arg_max): Description : This will play the trajectories multiple times so that trajectories will not fail. Arguments : arg_file_path - file path in which the trajectories are saved arg_file_name - file name of saved trajectories that we need to load arg_max - maximum no of attempts result : gives the result as true or false for the execution of the trajectories ###### *node_t5_2.py* This ROS Node is used for ur5_2 arm and it can interface the moveit package of ut5_2 arm to control the arm. The task of this arm starts only when the ur5_1 arm dispatches the prioritized orders and sends the goal to the server present in this node. On receiving goals from the client it will sort the packages from conveyor to the respective bins based on the color. The first thing that this node needs to do is interface the ur5_2 arm in gazebo with moveit planners. This will be carried out by the constructor of the class UR52Node where all the parameters of the manipulator is loaded. We have included all the functions present in this node with their descriptions. # ROS Node - Robotic Perception and manipulation - Ur5#2 ''' This python file runs a ROS-node of name Ur52Node. This node acts as a Action Server and this node is also an Action client to ROS-IOT server. So it will receive and send the goals asynchronously to the respective nodes This nodes controls the ur5_2 arm to pick the packages from the conveyor belt and drops the package in the respective bins Sorting is done by the goal received from the Action Client ''' # Importing required modules import datetime // To get system time import math // To convert degree to radians import copy // To make a copy of waypoints import threading // For asynchronous perfomance import rospy // To use ROS python functions import actionlib // Actionlib library for ROS import moveit_commander // To interface ur5 arm import moveit_msgs.msg // To get the states of the arm import geometry_msgs.msg // To use the geometry msgs of ROS from pkg_vb_sim.msg import LogicalCameraImage // To get the messages from LogicalCamera2 # To use the vacuum Gripper service, ConveyorBeltService from pkg_vb_sim.srv import conveyorBeltPowerMsg, vacuumGripper # Action and Result fields of ColorMsg.action file to access different fields of ROS Actions from pkg_task5.msg import ColorMsgAction, ColorMsgResult # Action, Goal and Result fields of msgROSIOT.action file to access different fields of ROS Actions from pkg_ros_iot_bridge.msg import msgRosIotAction, msgRosIotGoal, msgRosIotResult # Creating a Class Ur52Node class Ur52Node(object): '''Class UR52Node''' This class will act as controller for ur5_2 arm to pick the packages from the conveyor belt and drops it in the corresponding colored bins # Function to call neccesary parameters def func_nec(self): Description : This functions purpose to initialize several parameters and joint angles to make the arm work properly arguments : NONE results : Initialize the neccessary services and joint angles # Function to validate incoming goal def on_goal(self, goal_handle): Description : On receiving a goal from client this function will be executed. This function will accept the goals which are appropriate arguments : goal_handle - Incoming goals from clients result : It will either accepts the goal or rejects the goal # This function is to process incoming Goals. def process_goal(self, goal_handle): Description : This function is the process goal which is received from action client to sort the packages arguments : goal_handle - Incoming goals from clients result : send the goal to next stage of process and sends status of goal to clients. # Function to Send Goal to IOT server def send_goal_iot(self, *args): Description : This function will send goals to the IOT server from this Node using msgRosIot.Action file arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, dispatch time result : sends the goal to ROS IOT server # Function to get the state of sent Goal def on_transition(self, goal_handle): Description : This function monitor the states of all the goals which is sent to ROS-IOT server This function will give the current state of each goal. arguments : goal_handle - stacked up goals from send_goal function result : gives the result from the iot server # Function to sort the packages def func_for_sorting(self, *args): Description : This function will use the incoming goal parameters and sort the packages to the respective bins This function first calls some functions to stop the coveyor belt at appropriate position and to apply translation to the arm to go to the package. This function is also threaded to send goals to IOT server asynchronously arguments : This is a variadic function which will contain multiple arguments. * args - It has package name, package color, orderid, city, time, simulation time results : picks the package from conveyor and place it in the respective bins # Function to push data to ROS-IOT Server def push_data(self, *args): Description : This function is to pre-process the goals which is to be sent to IOT server using send goal function This function has a if statement according to the sheet name to send goals to the IOT server arguments : This is a variadic function which will contain multiple arguments. * args - It has sheetname, package name, package color, dispatch status orderid, city, time, dispatch time result : push the goal to ROS IOT server # Function to get translational Values def func_translation(self): Description : this function trasnslation subscribes to the logical camera 2 topic and applies cartesian translation to make the arm move to the package arguments : NONE ROS Subscriber : /eyrc/vb/logical_camera_2 result : push the translational values to ee_cartesian translation function return : float - translation_y # Callback Function for translation function def func_trans_callback(self, msg): Description : this is a callback function to get the translational values which in turn applied in cartesian translation arguments : msg - message received from ros subscriber of logical camera result : gets the y co-ordinate of the packages for applying translation # Function to control conveyor def func_control(self): Description : This function controls the conveyor belt to start and stop func_detect is called to detect whether any objects present in the belt and then it stops the belt. arguments : NONE result : Turn on and off the conveyor belt. # Function to Detect packages def func_detect(self): Description : this function detects whether there is a package in conveyor belt or not using logical camera 2. It also returns the val_y so that it can be picked by ur5_2 arm. arguments : NONE result : detects the package when it is in specific range # Callback Function for detect function def func_sub_callback(self, msg): Description : This function is a callback for func_detect In this function it will check for the packages rather than ur5 arm , so that the packages are identified by the camera and returns the y co-ordinate of the objects arguments : msg - message received from ros subscriber of logical camera 2 result : get the y position of the package return : float - value_y # Function to power up the conveyor while sorting def func_parallel(self): Description : this function to run the conveyor belt parallely while sorting the packages arguments : NONE result : power up the conveyor belt #Function to set_joint_angles to move ur5 arm def set_joint_angles(self, arg_list_joint_angles): Description : This function to set the joint angles of the ur5_2 arm to the required joint angles as mentioned. arguments : arg_list_joint_angles - list of joint angle values result : Moves the arm to the required joint angles # Function to set joint angles forcibly def hard_set_joint_angles(self, arg_list_joint_angles, arg_max_attempts): Description : This function to set the joint angles forcibly of the ur5_2 arm In case, If the arm fails to set the joint angles at the first attempt arguments : arg_list_joint_angles - list of joint angle values arg_max_attempts - maximum number of attempts results : gives the result as true or false for the execution of the trajectories # Function for cartesian translation def ee_cartesian_translation(self, trans_x, trans_y, trans_z): Description : This ee_cartesian_translation function is to move the end effector to the packages, the values are extracted using logical camera 2 arguments : trans_x - x co-ordinate value for translation trans_y - y co-ordinate value for translation trans_z - z co-ordinate value for translation result : translate the arm from current position to top of package #Function to cancel a goal @classmethod def on_cancel(cls, goal_handle): Description : This function is to cancel any incoming goal which is requested by the client arguments : goal - goal sent by action client result : cancels the incoming goal by goal id **Note** : If you need to see our complete code, please check on our submission files. #### pkg_moveit_ur5_1 and ur5_2 As discussed in the introduction and implementation, In this theme there are two robotic arms to be controlled. To control each arm, there is a need of a configuration package which should load all the parameters and interface the arm in both gazebo and moveit. We have configured this package on our own instead of the packages that are already available in vb_simulation_pkgs. The reason behind this is to get a best suitable configuration to the ur5 arms and we have also used RRT as a planning library. So, that the arm works better and gives the desired results. This package will have all the files which are necessary to interface and control the arm through move it and ROS nodes. Using the Rviz GUI we have also created a scene file which can use a saved file to avoid collisions with objects present in the gazebo world. The scene file of ur5_1 and ur5_2 are shown below ![scene_2](images/scene.png)","title":"Config and Action files"},{"location":"implement.html","text":"Implementation Objective The objective of this task is to implement an Autonomous Warehouse Management System to process, sort, dispatch and ship the packages based on incoming customer orders from different cities by taking into consideration the priorities allotted for the packages using two UR5 arms. Process Flow The important part of this implementation is the ROS communication. ROS acts as a effective median between all the platforms that we have used in the theme. First we will look into the flow chart of our implementation which shows the flow of data in different nodes. The explanation to the above image is mentioned below. The first process in this implementation is to get the incoming orders from HiveMQ using ROS-IOT Bridge. The orders that is received in ROS-IOT Bridge is sent to Ur5_1 arm node. The Ur5_1 arm node can prioritize the incoming goals and process the goals further. The ur5_1 arm pick the package from shelf and place it in the conveyor belt, then it will send the goal to ur5_2 arm node. On receiving goals from ur5_1 arm, ur5_2 arm node will look for that package using logical camera. If it detect the package, then it will sort the package from conveyor to the shipping bins based on it's color. Both the ur5 arm nodes will send the data to ROS-IOT bridge asynchronously to push the data into the google sheets. In google sheets, we use Dashboard sheet as a JSON endpoint for IOT Dashboard. IOT Dashboard is to show the status of all the orders in a user friendly display. Now, let's see all the components mentioned in process flow individually. ROS-IOT Bridge ROS-IOT Bridge plays the important and acts as a base for this task. As the name states this will be acting like a medium between ROS and IOT communication. As like in process flow, we have attached a flow chart for easy understanding. The explanation of this flow chart is given below. The orders from the client's are published in mqtt Topic which should be subscribed in this node to access the data in ROS. \u200b Subscription Topic - /eyrc/vb/ /orders To use the incoming orders in other ROS nodes, we have used ROS publisher which will publish all the incoming orders from MQTT topic \u200b Publication Topic - /ros_iot_bridge/mqtt/sub Apart from publishing to ROS topic, this node acts as a Action Server. So, that it can receive goals from multiple ROS Clients. On receiving any goal from the client, the node will be validating it using the arguments passed to it. The sheet name is the validater for the goals. We are using sheet name as validater because at the next step we are going to push all the data in goals to google sheets. If the goal is valid, then this bridge will push the data to various google sheets with respect to the sheet name in the goal Asynschronously. ur5_1 arm Node This node will control the ur5_1 arm present in the gazebo and rviz using moveit packages. There are two tasks that this arm needs to carry out, so we have two seperate classes in a single node to complete this tasks. The Class Camera will use the 2d camera as a sensor input and process the image to get color of all individual packages with their position as package name. To do this the camera needs to subscribe to the ROS topic. Subscription Topic - /eyrc/vb/camera_1/image_raw After subscribing to the ROS topic this will use the callback function to convert the raw_image data to image format. To get the package color there is a need of image processing unit which can make the image into suitable format to decode it. We have used QR Decoding method with the help of pyzbar to get better results. On completion of image processing, the image is decoded with the help of pyzbar. Though it is decoded and got the color of all the packages, we need to find it's position in the shelf. For enabling this, we have used some re-arranging methods with the help of the decoded data which can arrange the color of the packages in the proper sequence with the package name in it. Re-arranging Method - The re-arranging is done twice one with the x position of the decoded data and the y position of the decoded data. Finally the package name and color are stored in the list which can be used for further processing. The Class UR51Node will use the class camera to get the color and package name in the shelf. Before that the constructor of this class will interface the ur5 arm present in the gazebo to the moveit planners. Then this node will send the extracted package color and package name to ROS-IOT server to push the data into the Inventory Spreadsheet of the google sheets asynchronously. This node needs to subscribe to the ROS Topic which contains all the data of the incoming order which is published by ROS-IOT Bridge. Subscription Topic - /ros_iot_bridge/mqtt/sub This node will continuously make a callback to get the incoming orders by using ROS Subscriber. Whenever data is traced by the mqtt_callback function it will convert the message received to suitable format to process and sends to function algorithm. This function algorithm is the important segment in processing orders. This will decide the orders to be processed. The decision of this algorithm will depend on the priority of the orders. In this scenario, priority is of three types high, medium, low which in turn received as orders like medicines, food, clothes respectively. After prioritizing the packages, the arm needs to pick and place the packages from the shelf to the conveyor. This process is done with the help of the functions task and pick and place. Function task will receive the prioritized orders, but we need to check the availability of the product and get the product position in the shelf which can be further processed. To obtain this, we have used the lists extracted from the class Camera. In that list we have searched the prioritized order(in terms of color) and package color. Then the result of the search will be sent to the ur5_2 arm server and pick and place in one of the arguments. Function pick and place is used by the ur5_1 robotic manipulator to manipulate the packages from the shelf to the conveyor belt. To do this, it uses the saved trajectories present in the config folder of pkg_task5. We have also threaded this function so that this function will not wait for the data to be pushed to the IOT server. After dispatching each package to the conveyor the status of that package is also updated to the google sheets by using send goal iot function. There are certain other functions like store, push data, transition, play planned path which supports the above mentioned functions to complete their respective jobs. ur5_2 arm Node This node will control the ur5_2 arm present in the gazebo and rviz using moveit packages. This arm needs to sort the packages from the conveyor belt to the shipment bins based on the color of the packages. This node will receive the goals from the server in on goal function and validates it. Validation is done to process the goals which are relevant to this server else it will reject it. Once the goal is validated, the accepted goals are further processed using process goal function which in turn sends the processing to function sorting. Before knowing about the sorting function we will look at the supporting functions. To get the package closer to ur5_2 arm we need to control the conveyor belt. This is done with the help of the function control and this will power up the conveyor belt until the package reaches the specific point in the belt. To detect the packages we need to subscribe ROS topic of logical camera 2. Subscription Topic - /eyrc/vb/logical_camera_2 The callback function of this subscriber will continuosly monitor the position of the packages when it is in the logical camera's frame. After detecting the package, we need to move our arm from it's current position to top of the package. This will also use the subscription of the logical camera 2 topic. After detecting the values for the translation the values are passed to end effector translation function which will compute cartesian way points to move the arm. Now, coming back to sorting function which will use all the above mentioned supporting functions to complete the manipulation. We have threaded this function to make the belt run parallelly while the package being sorted. The color of this package received from the client is used for sorting. We have included one more thread to push data asynchronously to ROS-IOT server. After shipping each package from the conveyor to the bins the status of that package is also updated to the google sheets by using send goal iot function to ROS-IOT server. Also, there are some other functions like hard on_goal, on_cancel, set joint angles which supports the above mentioned functions to complete their respective jobs. Google Sheets There are multiple points in this theme to push data to spread sheet. The importance in pushing data to spreadsheet is to quickly check and validate the particular state of the goal because it will remain forever in the sheets. We have created a Inventory Management Sheet in google sheet which will contain five different sheets. The purpose of each sheet is mentioned below. Inventory sheet - This sheet will contain all the details of the packages that are available in the shelf (or) Inventory. IncomingOrders sheet - This sheet will contain all the details of the orders sent by the consumers. OrdersDispatched sheet - This sheet will contain all the details of the packages which are dispatched by the ur5_1 arm OrdersShipped sheet - This sheet will contain all the details of the packages which are shipped by the ur5_2 arm along with the estimated time of delivery. IOT Dashboard We have made a user-friendly dashboard where the live status of the packages present in the warehouse is displayed. The dashboard consists of containers in which the data like No. of Orders, No. of Dispatched Packages, No. of Shipped Packages and the Total Income incurred by the warehouse. Next a bar graph is depicted to represent the total time taken by a package till it is shipped after receiving the order. We have also included a Line graph which can give us the order time, dispatch time, shipment time with respect to order id in real time(secs). The purpose of this graph is to know the time delay between various processes. There is a Map displayed to show the cities from where the orders are received in real time. It also indicates the status of orders in the form of different coloured marker like: Red Marker - If the order is placed and neither dispatched nor shipped \u200b Yellow Marker - If the order is placed and dispatched and not shipped \u200b Green Marker \u2013 If the order is placed, dispatched and shipped. We have also included a table which will show all the necessary details of the orders which can be used to get the current state of a particular package. We have also included a video demonstration of our warehouse dashboard. please have a look into this for better understanding. We have discussed about all the files used in the implementation in API's Documentation.","title":"Implementation"},{"location":"implement.html#implementation","text":"","title":"Implementation"},{"location":"implement.html#objective","text":"The objective of this task is to implement an Autonomous Warehouse Management System to process, sort, dispatch and ship the packages based on incoming customer orders from different cities by taking into consideration the priorities allotted for the packages using two UR5 arms.","title":"Objective"},{"location":"implement.html#process-flow","text":"The important part of this implementation is the ROS communication. ROS acts as a effective median between all the platforms that we have used in the theme. First we will look into the flow chart of our implementation which shows the flow of data in different nodes. The explanation to the above image is mentioned below. The first process in this implementation is to get the incoming orders from HiveMQ using ROS-IOT Bridge. The orders that is received in ROS-IOT Bridge is sent to Ur5_1 arm node. The Ur5_1 arm node can prioritize the incoming goals and process the goals further. The ur5_1 arm pick the package from shelf and place it in the conveyor belt, then it will send the goal to ur5_2 arm node. On receiving goals from ur5_1 arm, ur5_2 arm node will look for that package using logical camera. If it detect the package, then it will sort the package from conveyor to the shipping bins based on it's color. Both the ur5 arm nodes will send the data to ROS-IOT bridge asynchronously to push the data into the google sheets. In google sheets, we use Dashboard sheet as a JSON endpoint for IOT Dashboard. IOT Dashboard is to show the status of all the orders in a user friendly display. Now, let's see all the components mentioned in process flow individually.","title":"Process Flow"},{"location":"implement.html#ros-iot-bridge","text":"ROS-IOT Bridge plays the important and acts as a base for this task. As the name states this will be acting like a medium between ROS and IOT communication. As like in process flow, we have attached a flow chart for easy understanding. The explanation of this flow chart is given below. The orders from the client's are published in mqtt Topic which should be subscribed in this node to access the data in ROS. \u200b Subscription Topic - /eyrc/vb/ /orders To use the incoming orders in other ROS nodes, we have used ROS publisher which will publish all the incoming orders from MQTT topic \u200b Publication Topic - /ros_iot_bridge/mqtt/sub Apart from publishing to ROS topic, this node acts as a Action Server. So, that it can receive goals from multiple ROS Clients. On receiving any goal from the client, the node will be validating it using the arguments passed to it. The sheet name is the validater for the goals. We are using sheet name as validater because at the next step we are going to push all the data in goals to google sheets. If the goal is valid, then this bridge will push the data to various google sheets with respect to the sheet name in the goal Asynschronously.","title":"ROS-IOT Bridge"},{"location":"implement.html#ur5_1-arm-node","text":"This node will control the ur5_1 arm present in the gazebo and rviz using moveit packages. There are two tasks that this arm needs to carry out, so we have two seperate classes in a single node to complete this tasks. The Class Camera will use the 2d camera as a sensor input and process the image to get color of all individual packages with their position as package name. To do this the camera needs to subscribe to the ROS topic. Subscription Topic - /eyrc/vb/camera_1/image_raw After subscribing to the ROS topic this will use the callback function to convert the raw_image data to image format. To get the package color there is a need of image processing unit which can make the image into suitable format to decode it. We have used QR Decoding method with the help of pyzbar to get better results. On completion of image processing, the image is decoded with the help of pyzbar. Though it is decoded and got the color of all the packages, we need to find it's position in the shelf. For enabling this, we have used some re-arranging methods with the help of the decoded data which can arrange the color of the packages in the proper sequence with the package name in it. Re-arranging Method - The re-arranging is done twice one with the x position of the decoded data and the y position of the decoded data. Finally the package name and color are stored in the list which can be used for further processing. The Class UR51Node will use the class camera to get the color and package name in the shelf. Before that the constructor of this class will interface the ur5 arm present in the gazebo to the moveit planners. Then this node will send the extracted package color and package name to ROS-IOT server to push the data into the Inventory Spreadsheet of the google sheets asynchronously. This node needs to subscribe to the ROS Topic which contains all the data of the incoming order which is published by ROS-IOT Bridge. Subscription Topic - /ros_iot_bridge/mqtt/sub This node will continuously make a callback to get the incoming orders by using ROS Subscriber. Whenever data is traced by the mqtt_callback function it will convert the message received to suitable format to process and sends to function algorithm. This function algorithm is the important segment in processing orders. This will decide the orders to be processed. The decision of this algorithm will depend on the priority of the orders. In this scenario, priority is of three types high, medium, low which in turn received as orders like medicines, food, clothes respectively. After prioritizing the packages, the arm needs to pick and place the packages from the shelf to the conveyor. This process is done with the help of the functions task and pick and place. Function task will receive the prioritized orders, but we need to check the availability of the product and get the product position in the shelf which can be further processed. To obtain this, we have used the lists extracted from the class Camera. In that list we have searched the prioritized order(in terms of color) and package color. Then the result of the search will be sent to the ur5_2 arm server and pick and place in one of the arguments. Function pick and place is used by the ur5_1 robotic manipulator to manipulate the packages from the shelf to the conveyor belt. To do this, it uses the saved trajectories present in the config folder of pkg_task5. We have also threaded this function so that this function will not wait for the data to be pushed to the IOT server. After dispatching each package to the conveyor the status of that package is also updated to the google sheets by using send goal iot function. There are certain other functions like store, push data, transition, play planned path which supports the above mentioned functions to complete their respective jobs.","title":"ur5_1 arm Node"},{"location":"implement.html#ur5_2-arm-node","text":"This node will control the ur5_2 arm present in the gazebo and rviz using moveit packages. This arm needs to sort the packages from the conveyor belt to the shipment bins based on the color of the packages. This node will receive the goals from the server in on goal function and validates it. Validation is done to process the goals which are relevant to this server else it will reject it. Once the goal is validated, the accepted goals are further processed using process goal function which in turn sends the processing to function sorting. Before knowing about the sorting function we will look at the supporting functions. To get the package closer to ur5_2 arm we need to control the conveyor belt. This is done with the help of the function control and this will power up the conveyor belt until the package reaches the specific point in the belt. To detect the packages we need to subscribe ROS topic of logical camera 2. Subscription Topic - /eyrc/vb/logical_camera_2 The callback function of this subscriber will continuosly monitor the position of the packages when it is in the logical camera's frame. After detecting the package, we need to move our arm from it's current position to top of the package. This will also use the subscription of the logical camera 2 topic. After detecting the values for the translation the values are passed to end effector translation function which will compute cartesian way points to move the arm. Now, coming back to sorting function which will use all the above mentioned supporting functions to complete the manipulation. We have threaded this function to make the belt run parallelly while the package being sorted. The color of this package received from the client is used for sorting. We have included one more thread to push data asynchronously to ROS-IOT server. After shipping each package from the conveyor to the bins the status of that package is also updated to the google sheets by using send goal iot function to ROS-IOT server. Also, there are some other functions like hard on_goal, on_cancel, set joint angles which supports the above mentioned functions to complete their respective jobs.","title":"ur5_2 arm Node"},{"location":"implement.html#google-sheets","text":"There are multiple points in this theme to push data to spread sheet. The importance in pushing data to spreadsheet is to quickly check and validate the particular state of the goal because it will remain forever in the sheets. We have created a Inventory Management Sheet in google sheet which will contain five different sheets. The purpose of each sheet is mentioned below. Inventory sheet - This sheet will contain all the details of the packages that are available in the shelf (or) Inventory. IncomingOrders sheet - This sheet will contain all the details of the orders sent by the consumers. OrdersDispatched sheet - This sheet will contain all the details of the packages which are dispatched by the ur5_1 arm OrdersShipped sheet - This sheet will contain all the details of the packages which are shipped by the ur5_2 arm along with the estimated time of delivery.","title":"Google Sheets"},{"location":"implement.html#iot-dashboard","text":"We have made a user-friendly dashboard where the live status of the packages present in the warehouse is displayed. The dashboard consists of containers in which the data like No. of Orders, No. of Dispatched Packages, No. of Shipped Packages and the Total Income incurred by the warehouse. Next a bar graph is depicted to represent the total time taken by a package till it is shipped after receiving the order. We have also included a Line graph which can give us the order time, dispatch time, shipment time with respect to order id in real time(secs). The purpose of this graph is to know the time delay between various processes. There is a Map displayed to show the cities from where the orders are received in real time. It also indicates the status of orders in the form of different coloured marker like: Red Marker - If the order is placed and neither dispatched nor shipped \u200b Yellow Marker - If the order is placed and dispatched and not shipped \u200b Green Marker \u2013 If the order is placed, dispatched and shipped. We have also included a table which will show all the necessary details of the orders which can be used to get the current state of a particular package. We have also included a video demonstration of our warehouse dashboard. please have a look into this for better understanding. We have discussed about all the files used in the implementation in API's Documentation.","title":"IOT Dashboard"},{"location":"intro.html","text":"Introduction The motive of this project is to implement an autonomous warehouse management system which takes order from the users and process the orders effectively based on the priority of the packages. The theme given to us is 'Vargi-Bots' which means separation of objects based on a category using robots. This theme uses two robotic arms named UR5_1 and UR5_2. This theme mainly focuses on Industry 4.0 where the warehouses are automated to reduce manpower, optimise the processes, carry out the tasks in a smart way and make continuous improvements. Orders like Medicines, Food and Clothes are sent to the MQTT server from different places. One robotic arm named UR5_1 will pick the respective packages from a shelf according to the incoming orders and place them on a conveyor belt. Another robotic arm named UR5_2 will collect these packages from the conveyor belt and places them into the respective bins for shipment of the packages to the respective places. Orders received are of different priorities like high priority, medium priority and low priority for medicine, food and clothes respectively. An algorithm is used to pick the packages based on priority to ship the high priority packages effectively. When the packages are sent out from the warehouse, email alerts are sent to the users notifying them about the status of the package. All the information related to the order, dispatch and shipment of each package is published on a google sheet and in a user-friendly website for easy accessing and understanding. These spreadsheets log every data which can be used for verification in future. The website gives real time information about the happenings in the warehouse with visual data like bar graphs and line graphs. Even a map is included to show from which place the order is generated and the status of the particular package. ROS, Gazebo and Moveit Let's see how we use ROS, Gazebo and Moveit platforms in our theme ROS ROS (Robot Operating System) is an open source platform, which has many libraries and tools to help software developers to create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. The version of ROS we have used is Melodic which supports industrial applications. In ROS we have different nodes which are used to communicate between the MQTT server and the UR5 robots. Gazebo In this project ROS and gazebo play a major role. ROS is the central processing unit of this project whereas Gazebo is the simulation environment which shows the demonstration of this project. These platforms are used for two-third of the complete objective of the project with the help of multiple ROS packages. ROS packages include multiple nodes (python scripts), action files, message files, config files. Gazebo offers the ability to simulate robots and other complex structures accurately and efficiently in almost any type of environment. We have used Gazebo 9.0.0 which can support almost all the packages of ROS melodic. In Gazebo we could simulate UR5 arms to know how it behaves in the environment according to our algorithm. Moveit MoveIt is the most widely used software for manipulation and has been used on over 150 real-time robots. It is released under the terms of the BSD license, and thus free for industrial, commercial, and research use. By incorporating the latest advances in motion planning, manipulation, 3D perception, kinematics, control and navigation, MoveIt is state of the art software for mobile manipulation. Implementation Video We have embedded a youtube video which will demonstrate the complete implementation of this theme. We will also discuss all the implementation techniques and API's used in this theme at the next section.","title":"Introduction"},{"location":"intro.html#introduction","text":"The motive of this project is to implement an autonomous warehouse management system which takes order from the users and process the orders effectively based on the priority of the packages. The theme given to us is 'Vargi-Bots' which means separation of objects based on a category using robots. This theme uses two robotic arms named UR5_1 and UR5_2. This theme mainly focuses on Industry 4.0 where the warehouses are automated to reduce manpower, optimise the processes, carry out the tasks in a smart way and make continuous improvements. Orders like Medicines, Food and Clothes are sent to the MQTT server from different places. One robotic arm named UR5_1 will pick the respective packages from a shelf according to the incoming orders and place them on a conveyor belt. Another robotic arm named UR5_2 will collect these packages from the conveyor belt and places them into the respective bins for shipment of the packages to the respective places. Orders received are of different priorities like high priority, medium priority and low priority for medicine, food and clothes respectively. An algorithm is used to pick the packages based on priority to ship the high priority packages effectively. When the packages are sent out from the warehouse, email alerts are sent to the users notifying them about the status of the package. All the information related to the order, dispatch and shipment of each package is published on a google sheet and in a user-friendly website for easy accessing and understanding. These spreadsheets log every data which can be used for verification in future. The website gives real time information about the happenings in the warehouse with visual data like bar graphs and line graphs. Even a map is included to show from which place the order is generated and the status of the particular package.","title":"Introduction"},{"location":"intro.html#ros-gazebo-and-moveit","text":"Let's see how we use ROS, Gazebo and Moveit platforms in our theme","title":"ROS, Gazebo and Moveit"},{"location":"intro.html#ros","text":"ROS (Robot Operating System) is an open source platform, which has many libraries and tools to help software developers to create robot applications. It provides hardware abstraction, device drivers, libraries, visualizers, message-passing, package management, and more. The version of ROS we have used is Melodic which supports industrial applications. In ROS we have different nodes which are used to communicate between the MQTT server and the UR5 robots.","title":"ROS"},{"location":"intro.html#gazebo","text":"In this project ROS and gazebo play a major role. ROS is the central processing unit of this project whereas Gazebo is the simulation environment which shows the demonstration of this project. These platforms are used for two-third of the complete objective of the project with the help of multiple ROS packages. ROS packages include multiple nodes (python scripts), action files, message files, config files. Gazebo offers the ability to simulate robots and other complex structures accurately and efficiently in almost any type of environment. We have used Gazebo 9.0.0 which can support almost all the packages of ROS melodic. In Gazebo we could simulate UR5 arms to know how it behaves in the environment according to our algorithm.","title":"Gazebo"},{"location":"intro.html#moveit","text":"MoveIt is the most widely used software for manipulation and has been used on over 150 real-time robots. It is released under the terms of the BSD license, and thus free for industrial, commercial, and research use. By incorporating the latest advances in motion planning, manipulation, 3D perception, kinematics, control and navigation, MoveIt is state of the art software for mobile manipulation.","title":"Moveit"},{"location":"intro.html#implementation-video","text":"We have embedded a youtube video which will demonstrate the complete implementation of this theme. We will also discuss all the implementation techniques and API's used in this theme at the next section.","title":"Implementation Video"}]}